import { createJsonRpcRequestPayload, standardizeJsonRpcRequestPayload } from '../core/json-rpc';
import { BaseModule } from './base-module';
import { SDKBase, MagicSDKAdditionalConfiguration } from '../core/sdk';
import { MagicExtensionError, MagicExtensionWarning } from '../core/sdk-exceptions';
import { createPromiEvent, encodeJSON, decodeJSON, encodeQueryParameters, decodeQueryParameters, storage, isPromiEvent } from '../util';
interface BaseExtension<TName extends string> extends BaseModule {
    compat?: {
        'magic-sdk': boolean | string;
        '@magic-sdk/react-native': boolean | string;
    };
}
declare abstract class BaseExtension<TName extends string> extends BaseModule {
    abstract readonly name: TName;
    private isInitialized;
    protected utils: {
        createPromiEvent: typeof createPromiEvent;
        isPromiEvent: typeof isPromiEvent;
        encodeJSON: typeof encodeJSON;
        decodeJSON: typeof decodeJSON;
        encodeQueryParameters: typeof encodeQueryParameters;
        decodeQueryParameters: typeof decodeQueryParameters;
        createJsonRpcRequestPayload: typeof createJsonRpcRequestPayload;
        standardizeJsonRpcRequestPayload: typeof standardizeJsonRpcRequestPayload;
        storage: typeof storage;
    };
    constructor();
    /**
     * Registers a Magic SDK instance with this Extension.
     */
    init(sdk: SDKBase): void;
    /**
     * Creates a deprecation warning wrapped with a native Magic SDK warning type.
     * Best practice is to warn users of upcoming deprecations at least one major
     * version before the change is implemented. You can use this method to
     * communicate deprecations in a manner consistent with Magic SDK core code.
     */
    protected createDeprecationWarning(options: {
        method: string;
        removalVersion: string;
        useInstead?: string;
    }): MagicExtensionWarning;
    /**
     * Creates a warning wrapped with a native Magic SDK warning type. This
     * maintains consistency in warning messaging for consumers of Magic SDK and
     * this Extension.
     */
    protected createWarning(code: string | number, message: string): MagicExtensionWarning;
    /**
     * Creates an error wrapped with a native Magic SDK error type. This maintains
     * consistency in error handling for consumers of Magic SDK and this
     * Extension.
     */
    protected createError<TData = any>(code: string | number, message: string, data: TData): MagicExtensionError<TData>;
    /**
     * Throws an error wrapped with a native Magic SDK error type. This maintains
     * consistency in error handling for consumers of Magic SDK and this
     * Extension.
     */
    protected raiseError<TData = any>(code: string | number, message: string, data: TData): void;
}
declare abstract class InternalExtension<TName extends string, TConfig extends any = any> extends BaseExtension<TName> {
    abstract readonly config: TConfig;
}
export declare abstract class Extension<TName extends string> extends BaseExtension<TName> {
    /**
     * This is a special constructor used to mark an extension as "official." Only
     * official extensions can interact with the iframe using custom JSON RPC
     * methods and business logic. This is intended for internal-use only and
     * provides no advantage to open-source extension developers.
     *
     * @internal
     */
    static Internal: typeof InternalExtension;
}
/**
 * These fields are exposed on the `Extension` type, but should be hidden from
 * the public interface.
 */
declare type HiddenExtensionFields = 'name' | 'init' | 'config' | 'compat';
/**
 * Gets the type contained in an array type.
 */
declare type UnwrapArray<T extends any[]> = T extends Array<infer P> ? P : never;
/**
 * Create a union type of Extension names from an array of Extension types given
 * by `TExt`.
 */
declare type ExtensionNames<TExt extends Extension<string>[]> = UnwrapArray<{
    [P in keyof TExt]: TExt[P] extends Extension<infer K> ? K : never;
}>;
/**
 * From the literal Extension name type given by `TExtName`, extract a
 * dictionary of Extension types.
 */
declare type GetExtensionFromName<TExt extends Extension<string>[], TExtName extends string> = {
    [P in TExtName]: Extract<UnwrapArray<TExt>, Extension<TExtName>>;
}[TExtName];
/**
 * Wraps a Magic SDK constructor with the necessary type information to support
 * a strongly-typed `Extension` interface.
 */
export declare type WithExtensions<SDK extends SDKBase> = {
    new <TCustomExtName extends string, TExt extends Extension<string>[] | {
        [P in TCustomExtName]: Extension<string>;
    }, TExtName extends string = TExt extends Extension<string>[] ? ExtensionNames<TExt> : keyof TExt>(apiKey: string, options?: MagicSDKAdditionalConfiguration<TCustomExtName, TExt>): SDK & {
        [P in TExtName]: TExt extends Extension<string>[] ? Omit<GetExtensionFromName<TExt, P>, HiddenExtensionFields> : TExt extends {
            [P in TExtName]: Extension<string>;
        } ? Omit<TExt[P], HiddenExtensionFields> : never;
    };
};
export {};
