var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { createJsonRpcRequestPayload, standardizeJsonRpcRequestPayload } from '../core/json-rpc';
import { BaseModule } from './base-module';
import { createExtensionNotInitializedError, MagicExtensionError, MagicExtensionWarning } from '../core/sdk-exceptions';
import { createPromiEvent, encodeJSON, decodeJSON, encodeQueryParameters, decodeQueryParameters, storage, isPromiEvent, } from '../util';
var BaseExtension = /** @class */ (function (_super) {
    __extends(BaseExtension, _super);
    function BaseExtension() {
        var _this = _super.call(this, undefined) || this;
        _this.isInitialized = false;
        _this.utils = {
            createPromiEvent: createPromiEvent,
            isPromiEvent: isPromiEvent,
            encodeJSON: encodeJSON,
            decodeJSON: decodeJSON,
            encodeQueryParameters: encodeQueryParameters,
            decodeQueryParameters: decodeQueryParameters,
            createJsonRpcRequestPayload: createJsonRpcRequestPayload,
            standardizeJsonRpcRequestPayload: standardizeJsonRpcRequestPayload,
            storage: storage,
        };
        var sdkAccessFields = ['request', 'transport', 'overlay', 'sdk'];
        // Disallow SDK access before initialization.
        return new Proxy(_this, {
            get: function (target, prop, receiver) {
                if (sdkAccessFields.includes(prop) && !_this.isInitialized) {
                    throw createExtensionNotInitializedError(prop);
                }
                return Reflect.get(target, prop, receiver);
            },
        });
    }
    /**
     * Registers a Magic SDK instance with this Extension.
     */
    BaseExtension.prototype.init = function (sdk) {
        if (this.isInitialized)
            return;
        this.sdk = sdk;
        this.isInitialized = true;
    };
    /**
     * Creates a deprecation warning wrapped with a native Magic SDK warning type.
     * Best practice is to warn users of upcoming deprecations at least one major
     * version before the change is implemented. You can use this method to
     * communicate deprecations in a manner consistent with Magic SDK core code.
     */
    BaseExtension.prototype.createDeprecationWarning = function (options) {
        var method = options.method, removalVersion = options.removalVersion, useInstead = options.useInstead;
        var useInsteadSuffix = useInstead ? " Use `" + useInstead + "` instead." : '';
        var message = "`" + method + "` will be removed from this Extension in version `" + removalVersion + "`." + useInsteadSuffix;
        return new MagicExtensionWarning(this, 'DEPRECATION_NOTICE', message);
    };
    /**
     * Creates a warning wrapped with a native Magic SDK warning type. This
     * maintains consistency in warning messaging for consumers of Magic SDK and
     * this Extension.
     */
    BaseExtension.prototype.createWarning = function (code, message) {
        return new MagicExtensionWarning(this, code, message);
    };
    /**
     * Creates an error wrapped with a native Magic SDK error type. This maintains
     * consistency in error handling for consumers of Magic SDK and this
     * Extension.
     */
    BaseExtension.prototype.createError = function (code, message, data) {
        return new MagicExtensionError(this, code, message, data);
    };
    /**
     * Throws an error wrapped with a native Magic SDK error type. This maintains
     * consistency in error handling for consumers of Magic SDK and this
     * Extension.
     */
    BaseExtension.prototype.raiseError = function (code, message, data) {
        throw new MagicExtensionError(this, code, message, data);
    };
    return BaseExtension;
}(BaseModule));
var InternalExtension = /** @class */ (function (_super) {
    __extends(InternalExtension, _super);
    function InternalExtension() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return InternalExtension;
}(BaseExtension));
var Extension = /** @class */ (function (_super) {
    __extends(Extension, _super);
    function Extension() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This is a special constructor used to mark an extension as "official." Only
     * official extensions can interact with the iframe using custom JSON RPC
     * methods and business logic. This is intended for internal-use only and
     * provides no advantage to open-source extension developers.
     *
     * @internal
     */
    Extension.Internal = InternalExtension;
    return Extension;
}(BaseExtension));
export { Extension };
//# sourceMappingURL=base-extension.js.map