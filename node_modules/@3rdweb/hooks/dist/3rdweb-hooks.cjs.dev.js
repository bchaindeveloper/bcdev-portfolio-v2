'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

require('regenerator-runtime/runtime.js');
var core = require('@web3-react/core');
var React = require('react');
var providers = require('@ethersproject/providers');
var invariant = require('tiny-invariant');
var units = require('@ethersproject/units');
var injectedConnector = require('@web3-react/injected-connector');
var chainIcons = require('@3rdweb/chain-icons');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var React__default = /*#__PURE__*/_interopDefault(React);
var invariant__default = /*#__PURE__*/_interopDefault(invariant);

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function getLibrary(provider) {
  return new providers.Web3Provider(provider, "any");
}

var ThirdwebContext = /*#__PURE__*/React.createContext({
  _inProvider: false,
  connectors: {},
  supportedChainIds: []
});
function useThirdwebContext() {
  var context = React.useContext(ThirdwebContext);
  invariant__default["default"](context._inProvider, "\n    Attempting to call useThirdwebContext from outside <ThirdwebProvider>, \n    did you forget to wrap your application in a <ThirdwebProvider>? \n  ");
  return context;
}
var ThirdwebWeb3Provider = function ThirdwebWeb3Provider(_ref) {
  var connectors = _ref.connectors,
      supportedChainIds = _ref.supportedChainIds,
      networkMetadata = _ref.networkMetadata,
      chainAddConfig = _ref.chainAddConfig,
      children = _ref.children;
  return /*#__PURE__*/React__default["default"].createElement(ThirdwebContext.Provider, {
    value: {
      _inProvider: true,
      connectors: connectors,
      supportedChainIds: supportedChainIds,
      networkMetadata: networkMetadata,
      chainAddConfig: chainAddConfig
    }
  }, /*#__PURE__*/React__default["default"].createElement(core.Web3ReactProvider, {
    getLibrary: getLibrary
  }, children));
};

var defaultChainAddConfig = {
  1: {
    chainId: "0x" + Number(1).toString(16),
    chainName: "Mainnet",
    nativeCurrency: {
      name: "Ethereum",
      symbol: "ETH",
      decimals: 18
    },
    rpcUrls: ["https://main-light.eth.linkpool.io/"]
  },
  4: {
    chainId: "0x" + Number(4).toString(16),
    chainName: "Rinkeby (ETH Testnet)",
    nativeCurrency: {
      name: "Ethereum",
      symbol: "ETH",
      decimals: 18
    },
    rpcUrls: ["https://rinkeby-light.eth.linkpool.io/"]
  },
  137: {
    chainId: "0x" + Number(137).toString(16),
    chainName: "Polygon Mainnet (Matic)",
    nativeCurrency: {
      name: "Matic",
      symbol: "MATIC",
      decimals: 18
    },
    rpcUrls: ["https://polygon-rpc.com"],
    blockExplorerUrls: ["https://polygonscan.com"]
  },
  250: {
    chainId: "0x" + Number(250).toString(16),
    chainName: "Fantom Opera",
    nativeCurrency: {
      name: "Fantom",
      symbol: "FTM",
      decimals: 18
    },
    rpcUrls: ["https://rpc.ftm.tools"],
    blockExplorerUrls: ["https://ftmscan.com"]
  },
  43114: {
    chainId: "0x" + Number(43114).toString(16),
    chainName: "Avalanche Mainnet C-Chain",
    nativeCurrency: {
      name: "Avalanche",
      symbol: "AVAX",
      decimals: 18
    },
    rpcUrls: ["https://api.avax.network/ext/bc/C/rpc"],
    blockExplorerUrls: ["https://cchain.explorer.avax.network"]
  },
  80001: {
    chainId: "0x" + Number(80001).toString(16),
    chainName: "Polygon Mumbai Testnet",
    nativeCurrency: {
      name: "Matic",
      symbol: "MATIC",
      decimals: 18
    },
    rpcUrls: ["https://rpc-mumbai.maticvigil.com", "https://rpc-mumbai.matic.today"],
    blockExplorerUrls: ["https://mumbai.polygonscan.com"]
  }
};
function useSwitchNetwork() {
  var _useThirdwebContext = useThirdwebContext(),
      chainAddConfig = _useThirdwebContext.chainAddConfig;

  var _useWeb3React = core.useWeb3React(),
      account = _useWeb3React.account;
      _useWeb3React.library;
      var connector = _useWeb3React.connector,
      chainId = _useWeb3React.chainId;

  var _useState = React.useState(false),
      isSwitching = _useState[0],
      setIsSwitching = _useState[1];

  var _useState2 = React.useState(),
      switchError = _useState2[0],
      setSwitchError = _useState2[1];

  var _useState3 = React.useState(),
      connectorProvider = _useState3[0],
      setConnectorProvider = _useState3[1];

  React.useEffect(function () {
    var getProvider = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.t0 = setConnectorProvider;
                _context.next = 3;
                return connector == null ? void 0 : connector.getProvider();

              case 3:
                _context.t1 = _context.sent;
                (0, _context.t0)(_context.t1);

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function getProvider() {
        return _ref.apply(this, arguments);
      };
    }();

    if (connector) {
      getProvider();
    }
  }, [connector]);
  React.useEffect(function () {
    setSwitchError(null);
  }, [chainId, account]);
  var canAttemptSwitch = React.useMemo(function () {
    return !!(connectorProvider != null && connectorProvider.request);
  }, [connectorProvider == null ? void 0 : connectorProvider.request]);
  var switchNetwork = React.useCallback( /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(newChainId) {
      var chainHex;
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (connectorProvider != null && connectorProvider.request) {
                _context2.next = 3;
                break;
              }

              setSwitchError(new Error("No provider available to switch"));
              return _context2.abrupt("return");

            case 3:
              setSwitchError(null);

              if (!(newChainId === chainId)) {
                _context2.next = 6;
                break;
              }

              return _context2.abrupt("return");

            case 6:
              setIsSwitching(true);
              chainHex = "0x" + newChainId.toString(16);
              _context2.prev = 8;
              _context2.next = 11;
              return connectorProvider.request({
                method: "wallet_switchEthereumChain",
                params: [{
                  chainId: chainHex
                }]
              });

            case 11:
              _context2.next = 38;
              break;

            case 13:
              _context2.prev = 13;
              _context2.t0 = _context2["catch"](8);

              if (!(_context2.t0.code === 4902 && chainAddConfig && chainAddConfig[newChainId])) {
                _context2.next = 26;
                break;
              }

              _context2.prev = 16;
              _context2.next = 19;
              return connectorProvider.request({
                method: "wallet_addEthereumChain",
                params: [chainAddConfig[newChainId]]
              });

            case 19:
              _context2.next = 24;
              break;

            case 21:
              _context2.prev = 21;
              _context2.t1 = _context2["catch"](16);
              setSwitchError(_context2.t1);

            case 24:
              _context2.next = 38;
              break;

            case 26:
              if (!(_context2.t0.code === 4902 && defaultChainAddConfig[newChainId])) {
                _context2.next = 37;
                break;
              }

              _context2.prev = 27;
              _context2.next = 30;
              return connectorProvider.request({
                method: "wallet_addEthereumChain",
                params: [defaultChainAddConfig[newChainId]]
              });

            case 30:
              _context2.next = 35;
              break;

            case 32:
              _context2.prev = 32;
              _context2.t2 = _context2["catch"](27);
              setSwitchError(_context2.t2);

            case 35:
              _context2.next = 38;
              break;

            case 37:
              setSwitchError(_context2.t0);

            case 38:
              _context2.prev = 38;
              setIsSwitching(false);
              return _context2.finish(38);

            case 41:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, null, [[8, 13, 38, 41], [16, 21], [27, 32]]);
    }));

    return function (_x) {
      return _ref2.apply(this, arguments);
    };
  }(), [chainAddConfig, connectorProvider, chainId]);
  return {
    switchNetwork: switchNetwork,
    canAttemptSwitch: canAttemptSwitch,
    isSwitching: isSwitching,
    switchError: switchError
  };
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function useConnectWallet() {
  var _useWeb3React = core.useWeb3React(),
      activate = _useWeb3React.activate;

  var _useThirdwebContext = useThirdwebContext(),
      connectors = _useThirdwebContext.connectors,
      supportedChainIds = _useThirdwebContext.supportedChainIds;

  return React.useCallback( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(connectorType, connectOptions) {
      var connectorOptions, _yield$import, InjectedConnector, _yield$import2, MagicConnector, _ref2, email, _connectorOptions, _yield$import3, WalletLinkConnector, _yield$import4, WalletConnectConnector;

      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              invariant__default["default"](connectors[connectorType], "\n        Invalid connect() call for connector: " + connectorType + ". \n        This connector is not defined on the <ThirdwebContext>.\n      ");
              connectorOptions = connectors[connectorType] ? _extends({}, connectors[connectorType], {
                supportedChainIds: supportedChainIds
              }) : {
                supportedChainIds: supportedChainIds
              };
              _context.t0 = connectorType;
              _context.next = _context.t0 === "injected" ? 5 : _context.t0 === "magic" ? 12 : _context.t0 === "walletlink" ? 21 : _context.t0 === "walletconnect" ? 28 : 35;
              break;

            case 5:
              _context.next = 7;
              return Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@web3-react/injected-connector')); });

            case 7:
              _yield$import = _context.sent;
              InjectedConnector = _yield$import.InjectedConnector;
              _context.next = 11;
              return activate(new InjectedConnector(connectorOptions));

            case 11:
              return _context.abrupt("return", _context.sent);

            case 12:
              _context.next = 14;
              return Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@web3-react/magic-connector')); });

            case 14:
              _yield$import2 = _context.sent;
              MagicConnector = _yield$import2.MagicConnector;
              _ref2 = connectOptions, email = _ref2.email;
              _connectorOptions = connectors[connectorType];
              _context.next = 20;
              return activate(new MagicConnector(_extends({}, _connectorOptions, {
                email: email
              })));

            case 20:
              return _context.abrupt("return", _context.sent);

            case 21:
              _context.next = 23;
              return Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@web3-react/walletlink-connector')); });

            case 23:
              _yield$import3 = _context.sent;
              WalletLinkConnector = _yield$import3.WalletLinkConnector;
              _context.next = 27;
              return activate(new WalletLinkConnector(connectorOptions));

            case 27:
              return _context.abrupt("return", _context.sent);

            case 28:
              _context.next = 30;
              return Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@web3-react/walletconnect-connector')); });

            case 30:
              _yield$import4 = _context.sent;
              WalletConnectConnector = _yield$import4.WalletConnectConnector;
              _context.next = 34;
              return activate(new WalletConnectConnector(connectorOptions));

            case 34:
              return _context.abrupt("return", _context.sent);

            case 35:
              throw new Error("Unsupported connector: " + connectorType);

            case 36:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function (_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }(), [connectors, supportedChainIds, activate]);
}

var defaultNetworkMetadata = {
  1: {
    chainName: "Ethereum",
    icon: chainIcons.Ethereum,
    symbol: "ETH",
    isTestnet: false
  },
  4: {
    chainName: "Rinkeby",
    icon: chainIcons.Ethereum,
    symbol: "ETH",
    isTestnet: true
  },
  137: {
    chainName: "Polygon",
    icon: chainIcons.Polygon,
    symbol: "MATIC",
    isTestnet: false
  },
  250: {
    chainName: "Fantom",
    icon: chainIcons.Fantom,
    symbol: "FTM",
    isTestnet: false
  },
  43114: {
    chainName: "Avalanche",
    icon: chainIcons.Avalanche,
    symbol: "AVAX",
    isTestnet: false
  },
  80001: {
    chainName: "Mumbai",
    icon: chainIcons.Polygon,
    symbol: "MATIC",
    isTestnet: true
  }
};
function useWeb3() {
  var connect = useConnectWallet();

  var _useThirdwebContext = useThirdwebContext(),
      connectors = _useThirdwebContext.connectors,
      networkMetadata = _useThirdwebContext.networkMetadata;

  var web3Context = core.useWeb3React();
  var library = web3Context.library,
      connector = web3Context.connector,
      account = web3Context.account,
      error = web3Context.error,
      chainId = web3Context.chainId,
      deactivate = web3Context.deactivate;

  var _useState = React.useState(),
      balance = _useState[0],
      setBalance = _useState[1];

  React.useEffect(function () {
    if (error != null && error.message.includes("The user rejected the request.")) {
      deactivate();
    }
  }, [error, deactivate]);
  React.useEffect(function () {
    var checkInjected = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var injected;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                injected = new injectedConnector.InjectedConnector({});
                _context.next = 3;
                return injected.isAuthorized();

              case 3:
                if (!_context.sent) {
                  _context.next = 5;
                  break;
                }

                connect("injected");

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function checkInjected() {
        return _ref.apply(this, arguments);
      };
    }();

    setTimeout(function () {
      checkInjected();
    }, 500);
  }, [connect]);
  React.useEffect(function () {
    var getBalance = /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var accountBalance;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!account) {
                  _context2.next = 7;
                  break;
                }

                _context2.next = 3;
                return library == null ? void 0 : library.getBalance(account);

              case 3:
                accountBalance = _context2.sent;
                setBalance({
                  value: accountBalance,
                  formatted: units.formatEther(accountBalance || 0).slice(0, 6)
                });
                _context2.next = 8;
                break;

              case 7:
                setBalance({
                  formatted: "0.0"
                });

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      return function getBalance() {
        return _ref2.apply(this, arguments);
      };
    }();

    getBalance();
  }, [library, account]);
  var activeProvider = React.useMemo(function () {
    return library == null ? void 0 : library.provider;
  }, [library == null ? void 0 : library.provider]);
  var disconnectWallet = React.useCallback( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
    var provider, request;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            provider = activeProvider;

            if (provider) {
              _context3.next = 3;
              break;
            }

            return _context3.abrupt("return");

          case 3:
            if (!(provider.isMetaMask && provider.request)) {
              _context3.next = 10;
              break;
            }

            _context3.next = 6;
            return provider.request({
              method: "wallet_requestPermissions",
              params: [{
                eth_accounts: {}
              }]
            });

          case 6:
            request = _context3.sent;
            return _context3.abrupt("return", request);

          case 10:
            if (!(connector && connector.close)) {
              _context3.next = 13;
              break;
            }

            connector.close();
            return _context3.abrupt("return");

          case 13:
            return _context3.abrupt("return", deactivate());

          case 14:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  })), [activeProvider, connector, deactivate]);
  var getNetworkMetadata = React.useCallback(function (_chainId) {
    return networkMetadata && networkMetadata[_chainId] || defaultNetworkMetadata[_chainId] || {
      chainName: "",
      iconUrl: "",
      symbol: ""
    };
  }, [networkMetadata]);
  return React.useMemo(function () {
    return {
      error: error,
      chainId: chainId,
      connector: connector,
      balance: balance,
      provider: library,
      activeProvider: activeProvider,
      // Force no null account
      address: account || undefined,
      connectors: Object.keys(connectors),
      connectWallet: connect,
      disconnectWallet: disconnectWallet,
      getNetworkMetadata: getNetworkMetadata
    };
  }, [account, chainId, balance, connector, activeProvider, connect, connectors, disconnectWallet, getNetworkMetadata, error, library]);
}

exports.ThirdwebWeb3Provider = ThirdwebWeb3Provider;
exports.useSwitchNetwork = useSwitchNetwork;
exports.useThirdwebContext = useThirdwebContext;
exports.useWeb3 = useWeb3;
